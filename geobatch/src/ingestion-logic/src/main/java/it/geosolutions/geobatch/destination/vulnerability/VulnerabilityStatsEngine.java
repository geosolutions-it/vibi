/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;
import it.geosolutions.jaiext.zonal.ZoneGeometry;

import java.awt.image.RenderedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;

import javax.media.jai.ROI;

import org.geotools.data.DataStore;
import org.geotools.jdbc.JDBCDataStore;
import org.geotools.geometry.jts.JTS;
import org.jaitools.imageutils.ROIGeometry;
import org.jaitools.media.jai.zonalstats.Result;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.metadata.spatial.PixelOrientation;
import org.opengis.referencing.operation.MathTransform;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vividsolutions.jts.geom.Geometry;

/**
 * @author DamianoG
 * 
 */
public class VulnerabilityStatsEngine {

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityStatsEngine.class);

    //private Properties targetURIs;

    private List<Double> distances;

    private Map<String, TargetInfo> targetInfo;

    public VulnerabilityStatsEngine(String basePath, Map vulnerabilityCfg,
            DataStore dataStore, String typeName, int pixelArea) throws IOException {
        final List<Double> allDistances = TargetPropertiesLoader.loadDistances(dataStore, typeName);

        targetInfo = VulnerabilityUtils.loadTargets(basePath, vulnerabilityCfg, pixelArea);

        distances = refineDistances(allDistances, pixelArea);
    }

    public List<Double> getDistances() {
        return distances;
    }

    /**
     * Scan all targets looking for actual distances which are globally needed
     * 
     * @param targetRasters
     * @param allDistances
     * @return
     */
    public List<Double> refineDistances(final List<Double> allDistances, int pixelArea) {
        Iterator<String> rasterIter = targetInfo.keySet().iterator();
        Set<Double> foundDistances = new TreeSet<Double>();        

        // Load all distances used by all targets
        while (rasterIter.hasNext()) {

            final String targetID = (String) rasterIter.next();
            TargetManager targetManager = targetInfo.get(targetID).getManager();
            
            // Load the target manager, init its status and check if the actual distance is a valid distance for it
            List<Double> targetDistances = targetManager.getDistances();
            for (Double d : targetDistances) {
                foundDistances.add(d);
            }
        }
        return new ArrayList<Double>(foundDistances);        
    }

    public MultipleBufferMap computeBuffersOnArcs(List<SimpleFeature> inputFeatures,
            List<Double> allDistances) {
        MultipleBufferMap mbm = new MultipleBufferMap();
        for (SimpleFeature feat : inputFeatures) {
            DistancesPair allDistancesForComputation = TargetPropertiesLoader
                    .createPairDistance(allDistances);
            Map<Double, Geometry> buffersMap = VulnerabilityUtils.computeBuffers(feat,
                    allDistancesForComputation);
            mbm.addMap(buffersMap);
        }
        return mbm;
    }

    /**
     * Retrieve the buffer of the arc in the raster space and crop the raster of the target in the raster of the buffer BBOX to run the stats on a
     * smaller raster
     * 
     * @param targetID
     * @param buffers
     * @return
     * @throws Exception
     */
    public RenderedImage cropImage(String targetID, Geometry roiGeom) throws Exception {
        RenderedImage image = targetInfo.get(targetID).getRaster();
        RenderedImage croppedImage = VulnerabilityUtils.cropImage(image, roiGeom);
        return croppedImage;
    }

    /**
     * Retrieve the raster space version of the specified cropArea geometry
     * 
     * @param targetID
     * @param buffers
     * @return
     * @throws Exception
     */
    public Geometry getRasterGeometry(String targetID, Geometry cropArea) throws Exception {
        MathTransform w2g = targetInfo.get(targetID).getGG2D().getCRSToGrid2D(PixelOrientation.UPPER_LEFT);
        Geometry roiGeom = VulnerabilityUtils.toRasterSpace(cropArea, w2g);
        return roiGeom;
    }

    /**
     * Retrieve the NoData value for the raster related to a target
     * 
     * @param targetID
     * @return
     */
    public Double getNoData(String targetID) {
        return targetInfo.get(targetID).getNodata();
    }

    public Map<String, TargetInfo> getTargetInfo() {
        return targetInfo;
    }

    /**
     * Check if a previous crop operation was succesful on all rasters
     * 
     * @param croppedImages
     * @return
     */
    public boolean validateCroppedImages(List<RenderedImage> croppedImages) {
        for (RenderedImage croppedImage : croppedImages) {
            if (croppedImage == null) {
                return false;
            }
        }
        return true;
    }

    /**
     * 
     * Compute the stats and create the statsMap
     * 
     * @param roiGeom
     * @param image
     * @param noData
     * @param resMap
     * @param forceToZero
     * @param targetManager
     * @param valuesToCount
     * @throws Exception
     */
    public void computeStats(List<Geometry> geometries, RenderedImage image, List<ResultStatsMap> resMapList,
            boolean forceToZero, Map<Integer, TargetInfo> targetPerBands) throws Exception {
        // Selection of the first TargetInfo object for calculating NoData and the world to grid transformation.
        TargetInfo targetInfo = null;
        // Set of all the input target bands
        Set<Integer> keys = targetPerBands.keySet();
        // Cycle on all the keys for searching the first element
        for (int key : keys) {
            targetInfo = targetPerBands.get(key);
            break;
        }
        // NoData value and World2Grid transform
        final Double noData = targetInfo.getNodata();
        final MathTransform w2g = targetInfo.getGG2D().getCRSToGrid2D(PixelOrientation.UPPER_LEFT);

        // List dimension
        int listSize = geometries.size();
        // Initialization of the ROI List
        List<ROI> roiList = new ArrayList<ROI>(listSize);
        // Iteration on the list and creation of the associated ROIGeometry object
        for (Geometry inputGeom : geometries) {

            Geometry geom = JTS.transform(inputGeom, w2g);

            ROI roi = new ROIGeometry(geom);

            roiList.add(roi);
        }

        // Statistics calculation
        List<ZoneGeometry> results = (List<ZoneGeometry>)VulnerabilityUtils.sumCellsInsideBuffer(roiList, image,
                noData, targetPerBands);

        // Result Handling

        Set<Integer> values = targetPerBands.keySet();
        // Cycle on all the targets
        for (int bandIndex : values) {
            // The TargetManager object associated to the selected target is taken
            final TargetManager targetManager = targetPerBands.get(bandIndex).getManager();
            
            int resultSize = results.size();
            
            for(int i = 0; i < resultSize; i++){
                ResultStatsMap resMap = resMapList.get(i);
                ZoneGeometry zone = results.get(i);
                // The results are added to the targetManager
                ResultStatsMap otherMap = resMap.clone();
                targetManager.handleResults(zone, otherMap, forceToZero, bandIndex);
                resMap.sum(otherMap);                
            }
        }
    }
    
    
    /**
     * 
     * Compute the stats and create the statsMap
     * 
     * @param features List of Geometry or SimpleFeature objects which contains all the geometries associated to each arc
     * @param image input target image
     * @param resMap map containing the results
     * @param forceToZero boolean indicating if the result should be set to 0
     * @param targetInfo object containing the informations associated with the selected target
     * @throws Exception
     */
    public void computeStats(List<Geometry> geometries, RenderedImage image, ResultStatsMap resMap,
            boolean forceToZero, Map<Integer, TargetInfo> targetPerBands) throws Exception {
        // Selection of the first TargetInfo object for calculating NoData and the world to grid transformation.
        TargetInfo targetInfo = null;
        // Set of all the input target bands
        Set<Integer> keys = targetPerBands.keySet();
        // Cycle on all the keys for searching the first element
        for (int key : keys) {
            targetInfo = targetPerBands.get(key);
            break;
        }
        // NoData value and World2Grid transform
        final Double noData = targetInfo.getNodata();
        final MathTransform w2g = targetInfo.getGG2D().getCRSToGrid2D(PixelOrientation.UPPER_LEFT);

        // List dimension
        int listSize = geometries.size();
        // Initialization of the ROI List
        List<ROI> roiList = new ArrayList<ROI>(listSize);
        // Iteration on the list and creation of the associated ROIGeometry object
        for (Geometry inputGeom : geometries) {

            Geometry geom = JTS.transform(inputGeom, w2g);

            ROI roi = new ROIGeometry(geom);

            roiList.add(roi);
        }

        // Statistics calculation
        List<ZoneGeometry> results = (List<ZoneGeometry>)VulnerabilityUtils.sumCellsInsideBuffer(roiList, image,
                noData, targetPerBands);

        // Result Handling

        Set<Integer> values = targetPerBands.keySet();
        // Cycle on all the targets
        for (int bandIndex : values) {
            // The TargetManager object associated to the selected target is taken
            final TargetManager targetManager = targetPerBands.get(bandIndex).getManager();
            
            for(ZoneGeometry zone : results){
                // The results are added to the targetManager
                ResultStatsMap otherMap = resMap.clone();
                targetManager.handleResults(zone, otherMap, forceToZero, bandIndex);
                resMap.sum(otherMap);                
            }
        }
    }

    /**
     * This method logs the main information before the vulnerability process start
     * 
     * Issue: logs all distance stored not those specifyed in the properties file
     * 
     * @param targetRasters
     * @param allDistances
     * @param targetMapping
     * @param zoneValues
     */
    private void logVulnerabilityConfiguration(List<Double> allDistances, Properties targetMapping,
            Properties zoneValues) {
        Iterator rasterIter = targetInfo.keySet().iterator();
        StringBuilder sb = new StringBuilder();
        sb.append("rasterLoaded:[ ");
        while (rasterIter.hasNext()) {
            sb.append((String) rasterIter.next()).append(", ");
        }
        sb.append("]");
        LOGGER.info(sb.toString());

        sb = new StringBuilder();
        sb.append("distanceLoaded:[ ");
        for (Double el : allDistances) {
            sb.append(el).append(", ");
        }
        sb.append("]");
        LOGGER.info(sb.toString());

        sb = new StringBuilder();
        sb.append("tableVulnerabilityMapping:[ ");
        Iterator targetMappingIter = targetMapping.keySet().iterator();
        while (targetMappingIter.hasNext()) {
            String key = (String) targetMappingIter.next();
            sb.append(key).append("-").append(targetMapping.getProperty(key)).append(", ");
        }
        sb.append("]");
        LOGGER.info(sb.toString());

        sb = new StringBuilder();
        sb.append("zoneValuesCopSuolo:[ ");
        Iterator zoneValuesIter = zoneValues.keySet().iterator();
        while (zoneValuesIter.hasNext()) {
            String key = (String) zoneValuesIter.next();
            sb.append(key).append("-").append(zoneValues.getProperty(key)).append(", ");
        }
        sb.append("]");
        LOGGER.info(sb.toString());
    }
}
