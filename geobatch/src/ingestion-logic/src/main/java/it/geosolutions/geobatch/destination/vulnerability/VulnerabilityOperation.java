/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import static it.geosolutions.geobatch.destination.vulnerability.VulnerabilityComputation.GEOID;
import static it.geosolutions.geobatch.destination.vulnerability.VulnerabilityComputation.PARTNER_FIELD;
import it.geosolutions.geobatch.destination.common.OutputObject;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.geotools.data.DataUtilities;
import org.geotools.data.DefaultTransaction;
import org.geotools.data.Query;
import org.geotools.data.Transaction;
import org.geotools.factory.CommonFactoryFinder;
import org.geotools.factory.Hints;
import org.geotools.feature.NameImpl;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.feature.type.Name;
import org.opengis.filter.Filter;
import org.opengis.filter.FilterFactory2;
import org.opengis.geometry.BoundingBox;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * @author DamianoG
 * 
 * This class is responsible for:
 * <ul>
 *      <li>Build the appropriate filter for the arcs source</li>
 *      <li>Persist the results of vulnerability process into a geotools Store</li>
 * </ul>
 *  
 * handling three modality, called <b>Operations</b> and implemented as inner classes: 
 * 
 * <ul>
 *      <li><b>UPDATE</b>: Add new records for distance not computed and update old record for target not computed. Never delete existing records</li>
 *      <li><b>INSERT</b>: Filter existing data [arcID,distance] and compute the rest of the arcs</li>
 *      <li><b>PURGE_INSERT</b>: Removes all existing data before start the computation. </li>      
 * </ul>
 * 
 * <b>NOTE</b> that each operation has the possibility of reducing the set of arcs to compute through a pagining-like system 
 * that it is configurable in the scripting action input event. 
 * 
 * This abstarct class can be instantiate through the instantiateWriter() method that given a write mode instantiate the right implementation
 * for using it in Update or Insert.  
 * 
 * TODO generalize it and use also in other processes.
 *
 */
public abstract class VulnerabilityOperation {

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityOperation.class);
    
    private final static boolean NO_DBWRITES_FOR_TESTS; 
    
    static {
        String noWrites = System.getProperty("it.geosolutions.vulnerability.nowritesondb");
        if (noWrites != null && noWrites.equalsIgnoreCase("TRUE")) {
            NO_DBWRITES_FOR_TESTS = true;
        } else {
            NO_DBWRITES_FOR_TESTS = false;
        }
    }
    
    public static Double DISTANCE_NOT_SET_VALUE = 0d;
    public static String DISTANCE_ID = "id_distanza";
    public static FilterFactory2 filterFactory = CommonFactoryFinder.getFilterFactory2();
    
    /**
     * The record to start with (Used for Filtering)
     */
    protected Long startOriginId;
    
    /**
     * The record to start with (Used for Filtering)
     */
    protected Long endOriginId;
    
    /**
     * Num of pages (Used for Filtering)
     */
    protected Long totPages;
    
    /**
     * PageNumber (Used for Filtering)
     */
    protected Long pageNumber;
    
    public enum OperationType {INSERT, UPDATE, PURGE_INSERT};
    
    /**
     * return a VulnerabilityResultsWriter suitable for the provided mode.
     * By default return the more conservative mode, WriterUpdate don't remove the records for a given partner.
     * @param mode
     * @return
     */
    public static VulnerabilityOperation instantiateWriter(OperationType mode){
        if(mode == null){
            return new UpdateOperation();
        }
        switch(mode){
            case PURGE_INSERT: return new PurgeInsertOperation();
            case INSERT: return new InsertOperation();
            case UPDATE: return new UpdateOperation();
            default: return new InsertOperation();
        }
    }
    
    public static VulnerabilityOperation instantiateWriterFromString(String mode){
        if(mode == null){
            return instantiateWriter(null);
        }
        return instantiateWriter(VulnerabilityOperation.OperationType.valueOf(mode));
    }
    
    protected void addNewVulnerabilityFeature(OutputObject vulnerabilityObject, String id,
            Map<String, Double> map, int partner_id) throws IOException {

        SimpleFeatureBuilder featureBuilder = new SimpleFeatureBuilder(vulnerabilityObject.getBuilder().getFeatureType());

        String[] p_key = id.split("\\.");
        for (AttributeDescriptor attr : vulnerabilityObject.getSchema().getAttributeDescriptors()) {
            if (attr.getLocalName().equals("id_geo_arco")) {
            	if (map.get("id_geo_arco") != null)
            		featureBuilder.add(map.get("id_geo_arco"));
            	else if (p_key != null && p_key.length > 0)
            		featureBuilder.add(p_key[0]);
            } else if (attr.getLocalName().equals("id_distanza")) {
            	if (map.get("id_distanza") != null)
            		featureBuilder.add(map.get("id_distanza"));
            	else if (p_key != null && p_key.length > 1) 
            		featureBuilder.add(p_key[1]);
            } else if (attr.getLocalName().equals("id_scenario")) {
            	if (map.get("id_scenario") != null)
            		featureBuilder.add(map.get("id_scenario"));
            } else if (attr.getLocalName().equals("id_sostanza")) {
            	if (map.get("id_sostanza") != null)
            		featureBuilder.add(map.get("id_sostanza"));
            } else if (attr.getLocalName().equals("flg_lieve")) {
            	if (map.get("flg_lieve") != null)
            		featureBuilder.add(map.get("flg_lieve"));
            } else if (attr.getLocalName().equals(PARTNER_FIELD)) {
                featureBuilder.add(String.valueOf(partner_id));
            } else {
                Object value = map.get(attr.getLocalName());
                if (value != null)
                {
                	featureBuilder.add(value);
                }
                else
                {
                	if (attr.getType().getBinding() == Double.class || attr.getType().getBinding() == BigDecimal.class)
                		featureBuilder.add(DISTANCE_NOT_SET_VALUE);
                	else
                		featureBuilder.add(null);
                }
                
            }
        }
        SimpleFeature feature = featureBuilder.buildFeature(id);
        feature.getUserData().put(Hints.USE_PROVIDED_FID, true);
        if (!NO_DBWRITES_FOR_TESTS) {
            vulnerabilityObject.getWriter().addFeatures(DataUtilities.collection(feature));
        }
        featureBuilder.reset();
    }

    public void writeOutputObjects(int trace, OutputObject outputObject,
            int total, String outputName, SimpleFeature inputFeature, String id,
            Map<String, Double> map, int partnerId) throws IOException {
    	
        Transaction rowTransaction = new DefaultTransaction();
        outputObject.getWriter().setTransaction(rowTransaction);

        try {
            addVulnerabilityFeature(outputObject, id, map, partnerId);
            if (!NO_DBWRITES_FOR_TESTS) {
                rowTransaction.commit();
            }
            //updateImportProgress(total, "Importing data in " + outputName);
        } catch (Exception e) {            
            rowTransaction.rollback();
            throw new IOException(e);
        } finally {
            rowTransaction.close();
        }
        
    }

    
    /**
     * Build a filter for iterate over the source table
     * 
     * @param idPartner
     * @param allFeaturesNumber
     * @param tileBbox Bounding box of the tile
     * @param userDefinedBbox Optional bounding fox for the envelope passed in input
     * @return
     */
    public Filter buildOriginFilterExtended(int idPartner, Integer allFeaturesNumber, BoundingBox tileBbox, BoundingBox userDefinedBbox, String idStart) {

        Filter filter = buildOriginFilter(idPartner, allFeaturesNumber);
        
        // If a tile bounding box is present, then it is added to the filter
        if (tileBbox != null && !tileBbox.isEmpty()) {
            filter = filterFactory.and(filter,
                    filterFactory.bbox(filterFactory.property("geometria"), tileBbox));
        }
        
        // If a user-defined bounding box is present, then it is added to the filter
        if (userDefinedBbox != null && !userDefinedBbox.isEmpty()) {
            filter = filterFactory.and(filter,
                    filterFactory.bbox(filterFactory.property("geometria"), userDefinedBbox));
        }
        
        if(idStart!=null){
            filter = filterFactory.and(filter, filterFactory.greaterOrEqual(filterFactory.property(GEOID),filterFactory.literal(idStart)));
        }
        
        return filter;
    }
    
    
    
    /**
     * Build a filter for iterate over the source table
     * 
     * @param idPartner
     * @param allFeaturesNumber
     * @return
     */
    public Filter buildOriginFilter(int idPartner, Integer allFeaturesNumber) {
        Long recordPerPages = null;
        if(totPages != null && pageNumber != null && allFeaturesNumber != null){
            recordPerPages = allFeaturesNumber / totPages ;
            this.startOriginId = ((pageNumber-1) * recordPerPages) +1;
            this.endOriginId = (pageNumber==totPages) ? allFeaturesNumber : startOriginId + recordPerPages;
        }

        if (this.startOriginId != null && this.endOriginId != null) {
            LOGGER.info("startOriginId: '" + startOriginId + "' - endOriginId: '" + endOriginId + "' - recordPerPages: '" + recordPerPages + "' - totPages: '" + totPages + "' - pageNumber: '" + pageNumber + "'");
            return filterFactory.and(
                    filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                            filterFactory.literal(idPartner)),
                    filterFactory.between(filterFactory.property(GEOID),
                            filterFactory.literal(this.startOriginId),
                            filterFactory.literal(this.endOriginId)));
            
        }
        
        // Simple filter on the partner
        Filter filter = filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                filterFactory.literal(idPartner));
        
        return filter;
    }

    
    
    /**
     * Add a new feature (or update an existing one)
     * 
     * @param vulnerabilityObject
     * @param id
     * @param map
     * @param partner_id
     * @throws IOException
     */
    protected abstract void addVulnerabilityFeature(OutputObject vulnerabilityObject, String id, Map<String, Double> map, int partner_id) throws IOException;
    
    /**
     * This method is responsible for initialize the table where the vulnerability process resilts will be stored
     * 
     * @param vulnerabilityObject
     * @param partner_id
     * @throws IOException
     */
    protected abstract void initFeature(OutputObject vulnerabilityObject, int partner_id) throws IOException;
    
    
    //
    // Accessor method
    //
    
    /**
     * @param startOriginId the startOriginId to set
     */
    public void setStartOriginId(Long startOriginId) {
        this.startOriginId = startOriginId;
    }

    /**
     * @param endOriginId the endOriginId to set
     */
    public void setEndOriginId(Long endOriginId) {
        this.endOriginId = endOriginId;
    }

    /**
     * @param totPages the totPages to set
     */
    public void setTotPages(Long totPages) {
        this.totPages = totPages;
    }

    /**
     * @param pageNumber the pageNumber to set
     */
    public void setPageNumber(Long pageNumber) {
        this.pageNumber = pageNumber;
    }
    
    //
    // CONCRETE CLASSES
    // 
    
    /**
     * Removes all existing data before start the computation.
     * if a subset of arcs is specified, remove just that arcs
     * 
     * @author DamianoG
     *
     */
    public static class PurgeInsertOperation extends InsertOperation{

        @Override
        protected void initFeature(OutputObject vulnerabilityObject, int partnerId)
                throws IOException {
            if(LOGGER.isDebugEnabled()){
                LOGGER.debug("PurgeInsert Mode: initFeature");
            }
            //    Setup the OutputObject (in the case the vulnerability table) remove old values for the partner and detect the max id
            Transaction transaction = new DefaultTransaction();
            try {
                    // remove previous data for the given partner and for specified arc range (if it is not null)
                    Filter removeFilter = filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                            filterFactory.literal(partnerId));
                    if(this.startOriginId != null && this.endOriginId != null){
                        removeFilter = filterFactory.and(
                                removeFilter,
                                filterFactory.between(filterFactory.property(GEOID),
                                        filterFactory.literal(this.startOriginId),
                                        filterFactory.literal(this.endOriginId)));
                    }
                    vulnerabilityObject.getWriter().setTransaction(transaction);
                    if (!NO_DBWRITES_FOR_TESTS) {
                        vulnerabilityObject.getSource().removeFeatures(removeFilter);     
                        transaction.commit();
                    }
            } catch (IOException e) {
                    LOGGER.error("Error while trying to delete vulnerability objects for partner " + partnerId, e);
                    transaction.rollback();
                    throw e;
            } finally {
                    transaction.close();
            }
        }        
    }
    
    /**
     *  Compute the rest of the arcs without remove the old values
     *  
     *  TODO Filter existing data [arcID,distance]
     * 
     * @author DamianoG
     *
     */
    public static class InsertOperation extends VulnerabilityOperation{

        @Override
        protected void addVulnerabilityFeature(OutputObject vulnerabilityObject, String id,
                Map<String, Double> map, int partnerId) throws IOException {
            
            /*if(LOGGER.isDebugEnabled()){
                LOGGER.debug("Insert Mode: addFeature...");
            }*/
            addNewVulnerabilityFeature(vulnerabilityObject, id, map, partnerId);
        }
        
        @Override
        protected void initFeature(OutputObject vulnerabilityObject, int partnerId)
                throws IOException {
            if(LOGGER.isDebugEnabled()){
                LOGGER.debug("Insert Mode: initFeature... nothing to do...");
            }
            //    Setup the OutputObject (in the case the vulnerability table) remove old values for the partner and detect the max id
//            Transaction transaction = new DefaultTransaction();
//            try {
//                    // remove previous data for the given partner
//                    // Filter removeFilter = filterFactory.     
//                    
//                    transaction.commit();   
//            } catch (IOException e) {
//                    LOGGER.error("Error while trying to delete vulnerability objects for partner " + partnerId, e);
//                    transaction.rollback();
//                    throw e;
//            } finally {
//                    transaction.close();
//            }
        }        
    }
    
    /**
     * Add new records for distance not computed and update old record for target not computed. Never delete existing records
     * 
     * @author DamianoG
     *
     */
    public static class UpdateOperation extends VulnerabilityOperation{

        @Override
        protected void addVulnerabilityFeature(OutputObject vulnerabilityObject, String id,
                Map<String, Double> map, int partnerId) throws IOException {
            
            SimpleFeatureBuilder featureBuilder = vulnerabilityObject.getBuilder();
            // get the PK (id_geoarco, distance) from FID
            String[] p_key = id.split("\\.");
            
            if(LOGGER.isDebugEnabled()){
                LOGGER.debug("Update Mode: addFeature ID: " + p_key[0] + " - " + p_key[1]);
            }
            
            // setup the filter for find if a record is already present or not
            Filter updateFilter = filterFactory.and(
                    filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                            filterFactory.literal(partnerId)),
                    filterFactory.and(
                            filterFactory.equals(filterFactory.property(GEOID),
                                    filterFactory.literal(p_key[0])),
                            filterFactory.equals(filterFactory.property(DISTANCE_ID),
                                    filterFactory.literal(p_key[1]))

                    ));
            
            List<Name> attributeNamesList = new ArrayList<Name>();
            List<Object> attributeValueList = new ArrayList<Object>();
            
            Iterator iter = map.keySet().iterator();
            while(iter.hasNext()){
                String key = (String)iter.next();
                attributeNamesList.add(new NameImpl(key));
                attributeValueList.add(map.get(key));
            }
            
            // If the feature p_key is not present means that a new distance is added so insert a new row
            if(vulnerabilityObject.getReader().getCount(new Query(vulnerabilityObject.getName(), updateFilter)) <= 0){
                if(LOGGER.isDebugEnabled()){
                    LOGGER.debug("feature[" + p_key[0] + " - " + p_key[1] + "] is not present... going to insert it");
                }
                addNewVulnerabilityFeature(vulnerabilityObject, id, map, partnerId);
            }
            // Otherwise just a new target is added so update an existing record 
            else{
                if(LOGGER.isDebugEnabled()){
                    LOGGER.debug("feature[" + p_key[0] + " - " + p_key[1] + "] is already present... going to update it");
                }
                vulnerabilityObject.getWriter().modifyFeatures(attributeNamesList.toArray(new NameImpl[attributeNamesList.size()]), attributeValueList.toArray(), updateFilter);
            }
            
            
        }

        @Override
        protected void initFeature(OutputObject vulnerabilityObject, int partner_id)
                throws IOException {
            if(LOGGER.isDebugEnabled()){
                LOGGER.debug("Update Mode: initFeature... nothing to do...");
            }
        }        
    }
}
